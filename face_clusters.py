# -*- coding: utf-8 -*- 

import os
import sys
import time
import json
import logging
import argparse

import cv2
import numpy as np

import serial
import RPi.GPIO as GPIO


def cluster_faces(faces_list, distance_threshold):
  """Clusters faces.

  Args:
    faces_list: a list of faces grouped by frame, i.e. results generated by
      represent_faces in face_reps.py.
    distance_threshold: a scalar value used to check if two faces are similar

  Returns:
    persons_list: a list of faces grouped by person.
  """
  persons_list = []

  cosine = lambda x, y: (x * y).sum()

  # Cluster faces using greedy algorithm.
  for frame_id, faces in enumerate(faces_list):
    # Merge face to the previous detected person if they are similar.
    plan = []
    for face in faces['faces']:
      face, rep = face['face'], face['rep']
      min_v, min_id = 1e8, -1
      for person_id, person in enumerate(persons_list):
        for other_rep in person['reps']:
          distance = 1 - cosine(rep, other_rep)
          if distance < min_v:
            min_v, min_id = distance, person_id

      # No similar person, plan to add a new one.
      if min_id == -1 or min_v > distance_threshold:
        plan.append({'plan': 'add'})

      # Similar person is found, plan to update.
      else:
        plan.append({'plan': 'update', 'person_id': min_id})
    # End for face in faces['faces']:

    # Update plan.
    assert len(plan) == len(faces['faces'])
    for face_id, elem in enumerate(plan):
      face, rep = faces['faces'][face_id]['face'], faces['faces'][face_id]['rep']
      if elem['plan'] == 'add':
        persons_list.append({
            'person_id': len(persons_list),
            'faces': [face],
            'reps': [rep],
            })
      else:
        person_id = elem['person_id']
        persons_list[person_id]['faces'].append(face)
        persons_list[person_id]['reps'].append(rep)

  return persons_list


def visualize_faces(persons_list, img_dim):
  """Visualizes clustering results.

  Args:
    persons_list: faces grouped by person.
  """
  cols = len(persons_list)
  rows = max([len(person['faces']) for person in persons_list])

  canvas = np.zeros((rows * img_dim, cols * img_dim, 3), np.uint8)
  for i, person in enumerate(persons_list):
    for j, face in enumerate(person['faces']):
      canvas[j * img_dim: (j + 1) * img_dim, i * img_dim: (i + 1) * img_dim, :] = face

  canvas = cv2.cvtColor(canvas, cv2.COLOR_RGB2BGR)
  cv2.imshow("Persons", canvas)
  key = cv2.waitKey(10000)
  cv2.destroyAllWindows()


def main(args):
  # LEDs.
  GPIO.setmode(GPIO.BCM)
  GPIO.setup(args.LED_running, GPIO.OUT)
  GPIO.setup(args.LED_frame_processed, GPIO.OUT)

  GPIO.output(args.LED_running, True)

  with open(args.input_path, 'rb') as fp:
    faces_list = np.load(fp)

  persons_list = cluster_faces(faces_list, args.distance_threshold)
  if len(persons_list)!=0:
  	visualize_faces(persons_list, args.imgDim)

  logging.info('Detected %i people in the video stream.', len(persons_list))
  with open(args.output_path, 'w') as fp:
    results = {
      'number_of_people': len(persons_list),
    }
    print >> fp, json.dumps(results, indent=2)

  GPIO.output(args.LED_running, False)
  GPIO.cleanup()

  fp = serial.Serial(args.serial_port, 9600)
  fp.write(str(len(persons_list)) + '\n')
  fp.close()

if __name__ == '__main__':
  logging.basicConfig(level=logging.DEBUG)

  parser = argparse.ArgumentParser()
  parser.add_argument(
      '--input_path', 
      type=str, 
      help='Path to the input npz file storing face embedding vectors.',
      default='output/faces.npz')
  parser.add_argument('--imgDim', type=int, default=96)
  parser.add_argument('--distance_threshold', type=float, default=0.2)
  parser.add_argument(
      '--output_path', 
      type=str, 
      help='Path to the output json file.',
      default='output/result.json')

  parser.add_argument('--LED_running', type=int, default=21)
  parser.add_argument('--LED_frame_processed', type=int, default=20)
  parser.add_argument('--serial_port', type=str, default='/dev/ttyACM0')

  args = parser.parse_args()
  logging.info(json.dumps(vars(args), indent=2))

  main(args)
  logging.info('Done')

  exit(0)
